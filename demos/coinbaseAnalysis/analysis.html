<!DOCTYPE html>
<html>

<head>
    <!-- Template -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="Matthew Gould - Agree with this innit" />
    <meta name="author" content="Matthew Gould" />
    <title>Matthew Gould - Coinbase Analysis</title>
    <link rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico" />

    <link href="../../css/styles.css" rel="stylesheet" type="text/css" />

    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
</head>

<body>
    <div id="app">
        <v-app>

            <!-- Upload -->
            <div v-if="uploadStage">
                <input type="file" @change="fileChanged" accept=".csv" ref="file" />
                <v-btn @click="fileConfirmed">Confirm File Selection</v-btn>
            </div>

            <!-- view data -->
            <div v-else>

                <!-- achievement chips -->
                <v-chip outlined v-if="diamondHands" title="Not sold"> ðŸ’ŽðŸ¤² </v-chip>
                <v-chip outlined v-for="achieve in genericAchieves" :key="achieve.text">
                    {{ achieve.value }} {{ achieve.text }}(s)
                </v-chip>

                <br><br>

                <!-- general stats -->
                <v-row>
                    <!-- total fee paid -->
                    <v-col cols="4">
                        <v-card height="100%">
                            <v-card-title class="text-h5">
                                Total Fees Paid
                            </v-card-title>

                            <v-card-subtitle>
                                {{ totalFeeClean }}
                            </v-card-subtitle>
                        </v-card>
                    </v-col>

                    <!-- total transacted -->
                    <v-col cols="4">
                        <v-card height="100%">
                            <v-card-title class="text-h5">
                                Total Transacted
                            </v-card-title>

                            <v-card-subtitle>
                                {{ totalTransactedClean }}
                            </v-card-subtitle>
                        </v-card>
                    </v-col>

                    <!-- total crypto hold -->
                    <v-col cols="4">
                        <v-card height="100%">
                            <v-card-title class="text-h5">
                                Crypto Held
                            </v-card-title>

                            <v-card-subtitle>
                                {{ totalCryptoHeld }} coins
                            </v-card-subtitle>
                        </v-card>
                    </v-col>

                    <!-- pie chart of buy breakdown -->
                    <v-col cols="4">
                        <v-card height="100%">
                            <v-card-title class="text-h5">
                                Buy Breakdown
                            </v-card-title>

                            <apexchart type="pie" width="380" :options="buyBreakdownOptions"
                                :series="buyBreakdownSeries">
                            </apexchart>
                        </v-card>
                    </v-col>
                </v-row>

                <br><br>

                <v-expansion-panels>

                    <!-- transaction calendar -->
                    <v-expansion-panel>
                        <v-expansion-panel-header>
                            <span>
                                <v-icon left>
                                    mdi-calendar-month
                                </v-icon>
                                Calendar
                            </span>
                        </v-expansion-panel-header>
                        <v-expansion-panel-content>
                            <v-toolbar flat>
                                <v-btn fab text color="grey darken-2" @click="calendarPrev">
                                    <v-icon>
                                        mdi-chevron-left
                                    </v-icon>
                                </v-btn>
                                <v-btn fab text color="grey darken-2" @click="calendarNext">
                                    <v-icon>
                                        mdi-chevron-right
                                    </v-icon>
                                </v-btn>
                                <v-btn v-if="calendarType != 'month'" @click="calendarType = 'month'">
                                    Back To Month View
                                </v-btn>
                                <v-spacer></v-spacer>
                            </v-toolbar>
                            <v-sheet height="720">
                                <v-calendar ref="calendar" v-model="calendarModel" :events="calendarData"
                                    @click:event="viewCalendarDay" @click:more="viewCalendarDay"
                                    @click:date="viewCalendarDay" :type="calendarType"></v-calendar>
                            </v-sheet>
                        </v-expansion-panel-content>
                    </v-expansion-panel>

                    <!-- table of current holdings -->
                    <v-expansion-panel>
                        <v-expansion-panel-header>
                            <span>
                                <v-icon left>
                                    mdi-database
                                </v-icon>
                                Holdings Table
                            </span>
                        </v-expansion-panel-header>
                        <v-expansion-panel-content>
                            <v-toolbar flat>
                                <v-text-field v-model="holdingTableSearch" append-icon="mdi-magnify" label="Search Holdings" single-line hide-details></v-text-field>
                            </v-toolbar>
                            <v-data-table :headers="holdingTableHeaders" :items="holdingTableItemsClean" :search="holdingTableSearch" :key="holdingTableKey"></v-data-table>
                        </v-expansion-panel-content>
                    </v-expansion-panel>

                    <!-- table of all transactions -->
                    <v-expansion-panel>
                        <v-expansion-panel-header>
                            <span>
                                <v-icon left>
                                    mdi-database
                                </v-icon>
                                Transactions Table
                            </span>
                        </v-expansion-panel-header>
                        <v-expansion-panel-content>
                            <v-toolbar flat>
                                <v-text-field v-model="transactionTableSearch" append-icon="mdi-magnify" label="Search Transactions" single-line hide-details></v-text-field>
                            </v-toolbar>
                            <v-data-table :headers="transactionTableHeaders" :items="transactionTableItems" :search="transactionTableSearch"></v-data-table>
                        </v-expansion-panel-content>
                    </v-expansion-panel>

                </v-expansion-panels>

            </div>

        </v-app>
    </div>
</body>
<!-- apex charts & vue apex charts -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-apexcharts"></script>
<!-- vue & vuetify -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
<!-- papa parse -->
<script src='https://cdn.jsdelivr.net/npm/papaparse@5.3.1/papaparse.min.js'></script>
<!-- axios -->
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script defer>

    Vue.component("apexchart", window.VueApexCharts);
    app = new Vue({
        el: '#app',
        vuetify: new Vuetify(),
        data() {
            return {
                currencies: ["AFA", "ALL", "DZD", "AOA", "ARS", "AMD", "AWG", "AUD", "AZN", "BSD", "BHD", "BDT", "BBD", "BYR", "BEF", "BZD", "BMD", "BTN", "BTC", "BOB", "BAM", "BWP", "BRL", "GBP", "BND", "BGN", "BIF", "KHR", "CAD", "CVE", "KYD", "XOF", "XAF", "XPF", "CLP", "CNY", "COP", "KMF", "CDF", "CRC", "HRK", "CUC", "CZK", "DKK", "DJF", "DOP", "XCD", "EGP", "ERN", "EEK", "ETB", "EUR", "FKP", "FJD", "GMD", "GEL", "DEM", "GHS", "GIP", "GRD", "GTQ", "GNF", "GYD", "HTG", "HNL", "HKD", "HUF", "ISK", "INR", "IDR", "IRR", "IQD", "ILS", "ITL", "JMD", "JPY", "JOD", "KZT", "KES", "KWD", "KGS", "LAK", "LVL", "LBP", "LSL", "LRD", "LYD", "LTL", "MOP", "MKD", "MGA", "MWK", "MYR", "MVR", "MRO", "MUR", "MXN", "MDL", "MNT", "MAD", "MZM", "MMK", "NAD", "NPR", "ANG", "TWD", "NZD", "NIO", "NGN", "KPW", "NOK", "OMR", "PKR", "PAB", "PGK", "PYG", "PEN", "PHP", "PLN", "QAR", "RON", "RUB", "RWF", "SVC", "WST", "SAR", "RSD", "SCR", "SLL", "SGD", "SKK", "SBD", "SOS", "ZAR", "KRW", "XDR", "LKR", "SHP", "SDG", "SRD", "SZL", "SEK", "CHF", "SYP", "STD", "TJS", "TZS", "THB", "TOP", "TTD", "TND", "TRY", "TMT", "UGX", "UAH", "AED", "UYU", "USD", "UZS", "VUV", "VEF", "VND", "YER", "ZMK"],

                uploadStage: true,
                diamondHands: true,

                totalFee: 0,
                totalFeeClean: 0,

                totalTransacted: 0,
                totalTransactedClean: 0,

                totalCryptoHeld: 0,

                fileObject: null,
                headers: [],
                data: [],

                calendarData: [],
                calendarModel: '',
                calendarType: 'month',

                transactionTableHeaders: [],
                transactionTableItems: [],
                transactionTableSearch: '',

                holdingTableHeaders: [
                    {sortable: true, text: 'Crypto', value: 'crypto'},
                    {sortable: true, text: 'Coins', value: 'coins'},
                    {sortable: true, text: 'Buy Value (-ve values represent profit)', value: 'buy'},
                    {sortable: true, text: 'Current Cash Out Value', value: 'cSale'},
                    {sortable: true, text: '%age', value: 'percentage'},
                ],
                holdingTableItems: [],
                holdingTableItemsClean: [],
                holdingTableSearch: '',
                holdingTableKey: 'HoldKey-0',

                cryptos: [],

                buyBreakdownOptions: {
                    chart: {},
                    labels: [],
                    responsive: []
                },
                buyBreakdownSeries: [],
                buysBreakdown: {},

                genericAchieves: [],

                coinGekoData: [],
                coinsProcessed: [],
                cryptoParam: '',
                cryptoParamArr: [],
                fiatParam: '',
                fiatParamArr: [],
                coinGekoRes: [],
            }
        },
        mounted() {

            console.log('mounted V0.8.1');
            // consider making this a req to https://api.coingecko.com/api/v3/coins/list instead
            axios.get('coinGekoCoinIds.json', {
                // headers: {
                //     'sec-fetch-site': 'cross-site',
                //     'sec-fetch-mode': 'cors',
                //     'authorization': 'kekwWhatAuth',
                // }
            })
                .then(res => {
                    this.coinGekoData = res.data;
                })
            ;

        },
        methods: {
            // CSV and processing
            fileChanged(event) {
                const reader = new FileReader();
                reader.onload = this.handleFileLoad;
                reader.readAsText(event.target.files[0]);
            },
            handleFileLoad(event) {
                let fileContent = event.target.result;
                this.fileObject = Papa.parse(fileContent);
            },
            fileConfirmed() {
                this.headers = this.fileObject.data[7];
                this.data = this.fileObject.data.splice(8, this.fileObject.data.length - 7);

                // console.log(this.headers);
                // console.log(this.data);

                this.runOperations();

                this.uploadStage = false;
            },

            // runs operations after the CSV is processed
            runOperations() {
                this.reset();
                this.formatHeadersForTable();
                this.processData();

                this.cleanHoldingTableData();
                this.renderBuys();
                this.preBuildCoinGekoQuery();

                // debug
                // console.log(this.genericAchieves);
            },

            // reset all data
            reset() {
                this.buyBreakdownOptions = {
                    chart: {
                        width: 380,
                        type: 'pie',
                    },
                    labels: [],
                    responsive: [{
                        breakpoint: 480,
                        options: {
                            chart: {
                                width: 200
                            },
                            legend: {
                                show: false,
                                position: 'bottom',
                            }
                        }
                    }]
                };
                this.buysBreakdown = {};

                this.buyBreakdownSeries = [];
                this.transactionTableItems = [];

                this.totalFee = 0;
                this.totalFeeClean = 0;
                this.totalTransacted = 0;
                this.totalTransactedClean = 0;
                this.totalCryptoHeld = 0;

                this.diamondHands = true;
            },

            // process data in each entry from CSV
            processData() {
                this.data.forEach(item => {
                    if(item[0] != undefined && item[0] != ''){
                        
                        this.handleEntryBuy(item);
                        this.handleEntryTable(item);
                        this.handleFeesPaid(item);
                        this.handleTransacted(item);
                        this.processDiamondHands(item);
                        this.processCryptoHold(item);
                        this.generateGeneralAchieves(item);
                        this.handleCalendarEntry(item);
                        this.getCoinTypes(item);

                    }
                })
            },

            // pie chart breakdown
            handleEntryBuy(item) {
                if (item[1] == 'Buy') {
                    let val = parseFloat(item[7]);
                    let curr = item[4];
                    if (this.buysBreakdown[curr] == undefined) {
                        this.buysBreakdown[curr] = val;
                    }
                    else this.buysBreakdown[curr] += val;
                }
            },
            renderBuys() {
                this.buyBreakdownOptions.labels = Object.keys(this.buysBreakdown);
                this.buyBreakdownSeries = Object.values(this.buysBreakdown);
            },

            // calculating how much cash has been transacted
            handleTransacted(item) {
                let num = parseFloat(item[7]);
                if (!Number.isNaN(num)) { // don't want NaNs
                    this.totalTransacted += num;
                    this.totalTransactedClean = JSON.parse(JSON.stringify(this.totalTransacted)).toFixed(2);
                }
            },

            // calculating how much fees had been paid
            handleFeesPaid(item) {
                let num = parseFloat(item[8]);
                if (!Number.isNaN(num)) { // don't want NaNs
                    this.totalFee += num;
                    this.totalFeeClean = JSON.parse(JSON.stringify(this.totalFee)).toFixed(2);
                }
            },

            // process how much crypto is currently held by the user
            processCryptoHold(item) {

                // console.log(item)

                let action = item[1];
                let crypto = item[2].toLowerCase();

                if(this.holdingTableItems[crypto] == undefined){
                    this.holdingTableItems[crypto] = {'crypto': crypto.toUpperCase(), 'coins': 0, 'buy': 0, 'cSale': 0, 'percentage': 0, 'obj': {}, 'conversions':{}};
                    this.buildCoinGekoQuery('crypto', crypto);
                }

                let transactedCrypto = parseFloat(item[3]);


                if (action == 'Sell' || action == 'Send') { // outgoing
                    this.totalCryptoHeld -= transactedCrypto;
                    this.holdingTableItems[crypto]['coins'] -= transactedCrypto;


                    if(action == 'Sell'){
                        this.holdingTableItems[crypto]['buy'] -= parseFloat(item[6]);
                    }

                    // console.log(item[9]);
                    // console.log( transactedCrypto );

                } else if (action == 'Buy' || action == 'Receive' || action == 'Rewards Income' || action == 'Coinbase Earn') { // incoming
                    this.totalCryptoHeld += transactedCrypto;
                    this.holdingTableItems[crypto]['coins'] += transactedCrypto;

                    if(action == 'Buy'){
                        this.holdingTableItems[crypto]['buy'] += parseFloat(item[6]);

                    }else if(action == 'Rewards Income'){
                        this.holdingTableItems[crypto]['buy'] -= (parseFloat(item[3]) * parseFloat(item[5]));

                    }else if(action == 'Coinbase Earn'){
                        this.holdingTableItems[crypto]['buy'] -= parseFloat(item[6]);

                    }

                    // console.log(item[9]);
                    // console.log( transactedCrypto );

                } else if (action == 'Convert') {
                    let cryptoFrom = '';
                    let cryptoTo = '';

                    str = item[9].replace(/,/g, ''); // remove allcases of comma

                    let floats = str.match(/[+-]?\d+(\.\d+)?/g)
                    .filter(str => {
                        return str.indexOf('.') > -1; // only want values with a '.'
                    })
                    .map(str => {
                        return parseFloat(str); // convert to float
                    });

                    this.totalCryptoHeld -= parseFloat(floats[0]); // converted from
                    this.totalCryptoHeld += parseFloat(floats[1]); // converted to

                    cryptoFrom = str.split(floats[0])[1].split(' ')[1].toLowerCase(); // get crypto converted from
                    cryptoTo = str.split(floats[1])[1].split(' ')[1].toLowerCase(); // get crypto converted to
                    
                    // console.log(item);
                    // console.log(floats);
                    // console.log( str.split(floats[0])[1].split(' ') );
                    // console.log(cryptoFrom);
                    // console.log( str.split(floats[1])[1].split(' ') );
                    // console.log(cryptoTo);

                    // init-ing crypto to if not existing
                    if(this.holdingTableItems[cryptoTo] == undefined){
                        this.holdingTableItems[cryptoTo] = {'crypto': cryptoTo.toUpperCase(), 'coins': 0, 'buy': 0, 'cSale': 0, 'percentage': 0, 'obj': {}, 'conversions':{}};
                        this.buildCoinGekoQuery('crypto', crypto);
                    }

                    // converted from
                    this.holdingTableItems[cryptoFrom]['coins'] -= parseFloat(floats[0]);
                    this.holdingTableItems[cryptoFrom]['buy'] -= parseFloat(item[6]);

                    // converted to
                    this.holdingTableItems[cryptoTo]['coins'] += parseFloat(floats[1]);
                    this.holdingTableItems[cryptoTo]['buy'] += parseFloat(item[6]);

                    // console.log(item[9]);
                    // console.log(floats);
                    // console.log(this.holdingTableItems)
                }

                // console.log(this.totalCryptoHeld);
            },

            // badges & achievements on top of page
            generateGeneralAchieves(item) {
                let createEntry = true;
                let action = item[1];

                this.genericAchieves.forEach(achieve => {
                    if (achieve.text == action) {
                        achieve.value += 1;
                        createEntry = false;
                    }
                });

                if (createEntry) {
                    this.genericAchieves.push({
                        value: 1,
                        text: action,
                    })
                }
            },
            processDiamondHands(item) {
                let action = item[1];

                if (action == 'Sell') {
                    this.diamondHands = false;
                }
            },

            //////////////////////
            // holding table stuff
            cleanHoldingTableData() {
                this.holdingTableItemsClean = [];

                Object.values( this.holdingTableItems ).forEach(ogItem => {
                    let item = JSON.parse(JSON.stringify(ogItem));

                    if(item['coins'] < 0){
                        item['coins'] = 0;
                    }

                    this.holdingTableItemsClean.push(item)
                });
            },

            //////////////////////////
            // transaction table stuff
            formatHeadersForTable() {
                this.transactionTableHeaders = [];

                this.headers.forEach(header => {
                    this.transactionTableHeaders.push({
                        text: header,
                        value: header,
                        sortable: true,
                    })
                });
            },
            handleEntryTable(item) {
                let tempObj = {};
                for (let i = 0; i < item.length; i++) {
                    tempObj[this.headers[i]] = item[i];
                }
                if (item.length == this.headers.length) this.transactionTableItems.push(tempObj); // avoids creating dodgy rows in the table
            },

            /////////////////
            // calendar stuff
            handleCalendarEntry(item) {
                if (item[0]) {
                    let dateClass = new Date(item[0])
                    let date = item[0].split('T');
                    let time = date[1].split('Z');

                    this.calendarData.push({
                        name: item[9],
                        start: dateClass,
                        color: 'blue',
                        times: false,
                        category: item[1],
                    });

                }
            },
            calendarPrev() {
                // console.log('calendarPrev()');
                this.$refs.calendar.prev();
            },
            calendarNext() {
                // console.log('calendarNext()');
                this.$refs.calendar.next();
            },
            viewCalendarDay(date) {

                // console.log(date)

                this.focus = date
                this.calendarType = 'day'
            },

            //////////////////
            // live data stuff
            getCoinTypes(item) {
                // to be used with https://www.coingecko.com/en/api/documentation

                if(item[2]){
                    // adding unique cryptos
                    let coin = item[2].toLowerCase();
                    if (!(this.cryptos.includes( coin ))) {
                        this.cryptos.push( coin );
                    }
                }

                // console.log(this.cryptos)
            },
            preBuildCoinGekoQuery(){
                console.log('preBuildCoinGekoQuery()');

                let coinsToGet = [];
                let coinsToFind = JSON.parse(JSON.stringify( this.cryptos ));
                let cryptoParam = "";
                let fiatParam = "";

                if(this.coinGekoData.length != 0){

                    this.coinGekoData.forEach( coinData => {
                        if (coinsToFind.includes( coinData.symbol )){

                            coinsToGet.push(coinData.id);
                            this.coinsProcessed.push( coinData );
                            this.holdingTableItems[coinData.symbol].obj = coinData;
                            // let index = coinsToFind.findIndex(coinData.symbol);
                            // coinsToFind.splice(index, 1);

                        }

                        // quick escape
                        if(coinsToFind.length === 0) return;
                    });

                    this.cryptoParam = coinsToGet.join(",");
                    this.fiatParam = Object.keys(this.buysBreakdown).join(",");
                    this.queryCoinGeko();

                }
            },
            buildCoinGekoQuery(type, name){ // may not use
                let response = '';
                switch(type){
                    // handling type crypto
                    case 'crypto':
                        response = this.coinGekoData.find((coin) => coin.symbol == type);
                        if(response) this.cryptoParamArr.push(response.id);
                    break;
                    // handling type fiat
                    case 'fiat':
                        this.fiatParamArr.push(type);
                        this.fiatParam = this.fiatParamArr.join(',');
                        response = type;
                    break;
                    // error
                    default:
                        console.error(`ERROR buildCoinGekoQuery(): was passed type ${type}`);
                    break;
                }
            },
            queryCoinGeko(self = this){
                console.log('queryCoinGeko()');

                axios.get('https://api.coingecko.com/api/v3/simple/price', {params: {'ids': self.cryptoParam, 'vs_currencies': self.fiatParam}} )
                    .then(res => {
                        self.coinGekoRes = res.data;
                        self.processCoinGeko();
                    })
                    .catch(err => {
                        setTimeout(queryCoinGeko, 5000, self)
                    })
                ;
            },
            processCoinGeko(){
                console.log('processCoinGeko()');

                this.holdingTableItems.forEach(item => {
                    console.log('====================================)');
                    console.log(item);
                    let coinConverstions = this.coinGekoRes[item.obj.id];
                    console.log(coinConverstions)
                    item.conversions = coinConverstions;
                    item.cSale = item.coins * item.conversions[ Object.keys(coinConverstions)[0] ]; // ultra MVP solution
                    item.percentage = 'inf';
                    if(item.buy != 0) item.percentage = (item.cSale / item.buy) * 100;
                    console.log(item);
                });

                this.cleanHoldingTableData();
            },

        },
        watch: {},
    })

</script>